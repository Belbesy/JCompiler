/*
 * DFA.cpp
 *
 *  Created on: Apr 6, 2013
 *      Author: raed
 */

#include "DFA.h"



DFA_Builder::DFA_Builder(FSA_TABLE NFATable_,vector<string> patterns_ ,vector<char> all_inputs_)
{
	NFATable = NFATable_;
	patterns = patterns_;
//	cout << "Patterns " << endl;
//	for(int i = 0; i < patterns.size();i++)
//		cout << patterns[i] << endl;
//	cout << " End of Patterns " << endl;
	all_inputs = all_inputs_;
	statesNum = NFATable.size();
	visited = new bool[statesNum];
	NFA_states = new FA_State*[statesNum];
	state_id = 0;
}


/**
 * in this method DFA logic was separated from subset construction,
 * this means DFA states were expressed using FA_State class , and were stored in DFA vector
 *
 * and sub-states of each state ware added in a separate vector called "DFA_states" , this vector
 * keeps only the id if state not the state itself
 *
 * lazy addition of sub-states was used to avoid duplicates, so visited array was used,
 * first mark sub-states you want add to you state then a flush of this sub-states in done
 *  in a separate step (flush_new_state) when we are done with sub-states addition
 *
 *sub-set construction was implemented using BFS ,each new state we added to the table is added
 *sub-set to the queue to explore it later
 */
void DFA_Builder::NFA_to_DFA()
{
	for(int i = 0;  i < statesNum;i++)
		visited[i] = false;

	FA_State* state = NFATable.front();

//	vector<FA_State*> ep;

//	cout << "Start state " << state << endl;
//	state->getTransition(EPSILON, ep);
//	cout << "Epsilon transitions" << endl;
//	for (int i = 0; i < ep.size(); i++)
//		cout << ep[i]->id << "  ";
//	cout << endl;



	empty_closure(state);
	flush_new_state();


	cout << "Start BFS" << endl;
	// start BFS
	queue<int> q;
	q.push(0);
	set<int> enqueued_states;
	int front , size , stateSize;
	while(!q.empty())
	{
		front = q.front();
		q.pop();
		cout << "State " << front << endl;

		stateSize = (int)DFA_states[front].size();
		size = all_inputs.size(); // get this array somehow
		for(int i = 0; i < size;i++)
		{
			char input = all_inputs[i];
//			cout << " Apply input " << input << endl;
			// apply this input to all state states
//			cout << " Front " << front << " " << input << " " << endl;
			for(int j = 0 ;j < stateSize;j++)
			{
				// apply this input to NFA state "state"
				state = DFA_states[front][j];
//				cout << " Apply to state " << state->id << endl;
				vector<FA_State*> result_states;
				state->getTransition(input, result_states);
				for (int k = 0; k < (int) result_states.size();k++)
				{
//					cout << " Got sub-state " << result_states[k]->id << endl;
					empty_closure(result_states[k]);
				}
			}
//			cout << endl;
			// now get the new state generated by this input
			int added_state = flush_new_state();
			if (added_state != -1)
			{
				if (added_state == state_id - 1 && !enqueued_states.count(added_state)) // check whether it exists before or not
				// new state,add it to your DFA states , and add to be queue to be explored later
				{
					q.push(added_state);
					enqueued_states.insert(added_state);
				}
				DFA[front]->AddTransition(input, DFA[added_state]);
				cout << "Edge from state " << front << " to " << added_state << " input " << input << endl;
			}
		}
		cout << " ------------- " << endl;
	}
	for(int i = 0 ;  i < state_id;i++)
	{
		cout << "State " << i  << " ";
		for(int j = 0 ; j < (int)DFA_states[i].size();j++)
			cout << "(" <<DFA_states[i][j]->id << ", " <<  DFA_states[i][j]->acceptingState  << "," << DFA_states[i][j]->matched_pattern << ")" << " ";
		cout << endl;
	}
}

/**
 * this method gets states visited array and adds them to DFA_states
 * creation of DFA state should be done here
 *
 * and returns the id of the added state
 *if this id == state_id , then it's a new state
 *else this state exists before and the returned id is its id
 */
int DFA_Builder::flush_new_state()
{
	// accumulate all visited states into new one state
	vector<FA_State*> sub_states;
	int matched_pattern = -1;
	for(int i = 0 ; i < statesNum;i++)
		if(visited[i])
		{
//			cout << NFA_states[i] << " " << NFA_states[i]->id << " " << i << endl;
			sub_states.push_back(NFA_states[i]);
			visited[i] = false;
			if(NFA_states[i]->acceptingState)
				if(matched_pattern == -1)
					// first time to get final state
					matched_pattern = NFA_states[i]->matched_pattern;
				else
					// get highest priority one
					matched_pattern = min(NFA_states[i]->matched_pattern , matched_pattern);
		}
	if(sub_states.size() == 0)
		return -1;

	// insert this state into your FA states tables
	int index = find(sub_states,DFA_states);
	if(index == -1)
	{
		// new state
		DFA_states.push_back(sub_states);
		FA_State* new_FA_state = new FA_State(state_id++);
		if(matched_pattern != -1) // final state
		{
			//  make sure that you have table of all patterns ( vector<int> patterns)
			new_FA_state->acceptingState = true;
			new_FA_state->matched_pattern = matched_pattern;
		}
		DFA.push_back(new_FA_state);
		return state_id-1;
	}
	return index;
}

/**
 * this method calculates the epsilon transitive closure of the state "state"
 * but it doesn't return anything , instead it marks this state as visited to be added later
 *
 * Using BFS
 */
void DFA_Builder::empty_closure(FA_State* state)
{
	FA_State* front ;
	int size;
	queue<FA_State*> q;
	visited[state->id] = true;
	NFA_states[state->id] = state;
	q.push(state);
	while(!q.empty())
	{
		front = q.front();
		q.pop();

		// get epsilon transition from current state
		vector<FA_State*> new_states;
		front->getTransition(EPSILON, new_states);

		// add states to queue to be explored later
		size = (int)new_states.size();
		for(int i = 0 ; i < size;i++)
		{
			int id = new_states[i]->id;
			if(!visited[id]) // if this state was visited no need to explore it again
			{
				visited[id] = true;
				NFA_states[id] = new_states[i];
				q.push(new_states[i]);
			}
		}
	}
}

/**
 * this method finds the position of the state in states
 * and returns -1 if doesn't exist
 *
 * this method assumes that all states are sorted  and no redundant sub-states
 */
int DFA_Builder::find(const vector<FA_State*>& state,const vector<vector<FA_State*> > states)
{
	int size = (int)states.size() , stateSize;
	for(int i = 0 ; i < size;i++)
	{
		stateSize = states[i].size();
		if(stateSize != (int)state.size())
			continue;
		bool similar = true;
		for(int j = 0; j < stateSize;j++)
			if(state[j] != states[i][j])
			{
				similar = false;
				break;
			}
		if(similar)
			return i;
	}
	return -1;
}

DFA_Builder::~DFA_Builder()
{
}

// =================================== Minimzation ==========================================

// if Y is in W

GROUP::iterator inside(SET a, GROUP g) {
	foreach(b, g) {
		if (b->size() != a.size())
			continue;
		bool match = true;
		foreach(e, a)
			if (b->find(*e) == b->end()) {
				match = false;
				break;
			}
		if (match)
			return b;
	}
	return g.end();
}

// difference

SET difference(SET Y, SET X) {
	SET result;
	vector<int> v(max(Y.size(), X.size()));
	v.resize(set_difference(all(Y), all(X),v.begin())  - v.begin());
	result.insert(v.begin(), v.end());
	return result;
}

SET intersect(SET Y, SET X) {
	SET result;
	vector<int> v(max(Y.size(), X.size()));
	v.resize(set_intersection(all(Y), all(X),v.begin())  - v.begin());
	result.insert(v.begin(), v.end());
	return result;
}

//	P := {F, Q \ F};
//	W := {F};
//	while (W is not empty) do
//	     choose and remove a set A from W
//	     for each c in ∑ do
//	          let X be the set of states for which a transition on c leads to a state in A
//	          for each set Y in P for which X ∩ Y is nonempty do
//	               replace Y in P by the two sets X ∩ Y and Y \ X
//	               if Y is in W
//	                    replace Y in W by the same two sets
//	               else
//	                    if |X ∩ Y| <= |Y \ X|
//	                         add X ∩ Y to W
//	                    else
//	                         add Y \ X to W
//	          end;
//	     end;
//	end;


FSA_TABLE minimize(FSA_TABLE fa) {

	int** trans = new int *[fa.size()];

	for (size_t i = 0; i < fa.size(); i++) {
		trans[i] = new int[300];
		for (int j = 0; j < 300; j++) {
			trans[i][j] = -1;
		}
	}

	// Preparing F, Q/F;
	SET accepting, others;
	map<int, FA_State *> old_states;

	foreach(it, fa) {

		old_states[(*it)->id] = (*it);
		foreach(t, (*it)->transitions_to)
			trans[(*it)->id][(int) (t->first)] = t->second->id;
		if ((*it)->acceptingState)
			accepting.insert((*it)->id);
		else
			others.insert((*it)->id);
	}

	//	P := {F, Q \ F};
	GROUP P;
	P.push_back(accepting);
	P.push_back(others);

	//	W := {F};
	GROUP W;
	W.push_back(accepting);

	//	while (W is not empty) do
	while (!W.empty()) {
		//	choose and remove a set A from W
		SET A = *W.begin();
		W.erase(W.begin());
		// for each c in ∑ do
		for (int c = 0; c < 300; c++) {
			SET X;

			// let X be the set of states for which a transition on c leads to a state in A
			for (size_t from_id = 0; from_id < fa.size(); from_id++)
				if (A.find(trans[from_id][c]) != A.end())
					X.insert(from_id);

			// for each set Y in P
			foreach(Y, P) {
				SET intersec = intersect(*Y, X);
				if (intersec.empty())
					continue;
				// for which X ∩ Y is nonempty do

				SET diff = difference(*Y, X);
				// replace Y in P by the two sets X ∩ Y and Y \ X
				P.erase(Y);
				P.push_back(intersec);
				P.push_back(diff);

				//if Y is in W
				GROUP::iterator it = inside(*Y, W);
				if (it != W.end()) {
					//replace Y in W by the same two sets
					W.erase(it);
					W.push_back(intersec);
					W.push_back(diff);
				} else {
					//	if |X ∩ Y| <= |Y \ X|
					if (intersec.size() < diff.size()) {
						//	add X ∩ Y to W
						if (!intersec.empty())
							W.push_back(intersec);
					} else {
						//	add Y \ X to W
						if (!diff.empty())
							W.push_back(diff);
					}
				}
			}

		}

	}

	FSA_TABLE new_dfa;

	map<int, int> new_id;
	for (size_t i = 0; i < P.size(); i++)
		foreach(s, P[i])
			new_id[*s] = i;

	int** new_trans = new int *[P.size()];

	for (size_t i = 0; i < P.size(); i++) {
		new_trans[i] = new int[300];
		for (int j = 0; j < 300; j++) {
			new_trans[i][j] = -1;
		}
	}

	for (size_t i = 0; i < P.size(); i++)
		foreach(s, P[i])
			foreach(t, old_states[*s]->transitions_to)
				new_trans[*s][(int) (t)->first] = new_id[(t)->second->id];

	vector<FA_State *> new_states;
	for (size_t i = 0; i < P.size(); i++) {
		FA_State* new_s = new FA_State(i);
		new_s->acceptingState = old_states[*P[i].begin()]->acceptingState;
		new_states.push_back(new_s);
	}

	for (size_t i = 0; i < P.size(); i++) {
		for (int j = 0; j < 300; j++)
			if (new_trans[i][j] > -1) {
				new_states[i]->transitions_to.insert(make_pair(char(j), new_states[new_trans[i][j]]));
				new_states[new_trans[i][j]]->transitions_from.insert(new_states[i]);
			}

	}

	for (size_t i = 0; i < P.size(); i++) 
		new_dfa.push_back(new_states[i]);
	

	return new_dfa;
}


