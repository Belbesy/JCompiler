/*
 * DFA.cpp
 *
 *  Created on: Apr 6, 2013
 *      Author: raed
 */

#include "DFA.h"



DFA_Builder::DFA_Builder(FSA_TABLE NFATable_,vector<string> patterns_ ,vector<char> all_inputs_)
{
	NFATable = NFATable_;
	patterns = patterns_;
//	cout << "Patterns " << endl;
//	for(int i = 0; i < patterns.size();i++)
//		cout << patterns[i] << endl;
//	cout << " End of Patterns " << endl;
	all_inputs = all_inputs_;
	statesNum = NFATable.size();
	visited = new bool[statesNum];
	NFA_states = new FA_State*[statesNum];
	state_id = 0;
}


/**
 * in this method DFA logic was separated from subset construction,
 * this means DFA states were expressed using FA_State class , and were stored in DFA vector
 *
 * and sub-states of each state ware added in a separate vector called "DFA_states" , this vector
 * keeps only the id if state not the state itself
 *
 * lazy addition of sub-states was used to avoid duplicates, so visited array was used,
 * first mark sub-states you want add to you state then a flush of this sub-states in done
 *  in a separate step (flush_new_state) when we are done with sub-states addition
 *
 *sub-set construction was implemented using BFS ,each new state we added to the table is added
 *sub-set to the queue to explore it later
 */
void DFA_Builder::NFA_to_DFA()
{
	for(int i = 0;  i < statesNum;i++)
		visited[i] = false;

	FA_State* state = NFATable.front();

//	vector<FA_State*> ep;

//	cout << "Start state " << state << endl;
//	state->getTransition(EPSILON, ep);
//	cout << "Epsilon transitions" << endl;
//	for (int i = 0; i < ep.size(); i++)
//		cout << ep[i]->id << "  ";
//	cout << endl;



	empty_closure(state);
	flush_new_state();


	cout << "Start BFS" << endl;
	// start BFS
	queue<int> q;
	q.push(0);
	set<int> enqueued_states;
	int front , size , stateSize;
	while(!q.empty())
	{
		front = q.front();
		q.pop();
		cout << "State " << front << endl;

		stateSize = (int)DFA_states[front].size();
		size = all_inputs.size(); // get this array somehow
		for(int i = 0; i < size;i++)
		{
			char input = all_inputs[i];
//			cout << " Apply input " << input << endl;
			// apply this input to all state states
//			cout << " Front " << front << " " << input << " " << endl;
			for(int j = 0 ;j < stateSize;j++)
			{
				// apply this input to NFA state "state"
				state = DFA_states[front][j];
//				cout << " Apply to state " << state->id << endl;
				vector<FA_State*> result_states;
				state->getTransition(input, result_states);
				for (int k = 0; k < (int) result_states.size();k++)
				{
//					cout << " Got sub-state " << result_states[k]->id << endl;
					empty_closure(result_states[k]);
				}
			}
//			cout << endl;
			// now get the new state generated by this input
			int added_state = flush_new_state();
			if (added_state != -1)
			{
				if (added_state == state_id - 1 && !enqueued_states.count(added_state)) // check whether it exists before or not
				// new state,add it to your DFA states , and add to be queue to be explored later
				{
					q.push(added_state);
					enqueued_states.insert(added_state);
				}
				DFA[front]->AddTransition(input, DFA[added_state]);
				cout << "Edge from state " << front << " to " << added_state << " input " << input << endl;
			}
		}
		cout << " ------------- " << endl;
	}
	for(int i = 0 ;  i < state_id;i++)
	{
		cout << "State " << i  << " ";
		for(int j = 0 ; j < (int)DFA_states[i].size();j++)
			cout << "(" <<DFA_states[i][j]->id << ", " <<  DFA_states[i][j]->acceptingState  << "," << DFA_states[i][j]->matched_pattern << ")" << " ";
		cout << endl;
	}
}

/**
 * this method gets states visited array and adds them to DFA_states
 * creation of DFA state should be done here
 *
 * and returns the id of the added state
 *if this id == state_id , then it's a new state
 *else this state exists before and the returned id is its id
 */
int DFA_Builder::flush_new_state()
{
	// accumulate all visited states into new one state
	vector<FA_State*> sub_states;
	int matched_pattern = -1;
	for(int i = 0 ; i < statesNum;i++)
		if(visited[i])
		{
//			cout << NFA_states[i] << " " << NFA_states[i]->id << " " << i << endl;
			sub_states.push_back(NFA_states[i]);
			visited[i] = false;
			if(NFA_states[i]->acceptingState)
				if(matched_pattern == -1)
					// first time to get final state
					matched_pattern = NFA_states[i]->matched_pattern;
				else
					// get highest priority one
					matched_pattern = min(NFA_states[i]->matched_pattern , matched_pattern);
		}
	if(sub_states.size() == 0)
		return -1;

	// insert this state into your FA states tables
	int index = find(sub_states,DFA_states);
	if(index == -1)
	{
		// new state
		DFA_states.push_back(sub_states);
		FA_State* new_FA_state = new FA_State(state_id++);
		if(matched_pattern != -1) // final state
		{
			//  make sure that you have table of all patterns ( vector<int> patterns)
			new_FA_state->acceptingState = true;
			new_FA_state->matched_pattern = matched_pattern;
		}
		DFA.push_back(new_FA_state);
		return state_id-1;
	}
	return index;
}

/**
 * this method calculates the epsilon transitive closure of the state "state"
 * but it doesn't return anything , instead it marks this state as visited to be added later
 *
 * Using BFS
 */
void DFA_Builder::empty_closure(FA_State* state)
{
	FA_State* front ;
	int size;
	queue<FA_State*> q;
	visited[state->id] = true;
	NFA_states[state->id] = state;
	q.push(state);
	while(!q.empty())
	{
		front = q.front();
		q.pop();

		// get epsilon transition from current state
		vector<FA_State*> new_states;
		front->getTransition(EPSILON, new_states);

		// add states to queue to be explored later
		size = (int)new_states.size();
		for(int i = 0 ; i < size;i++)
		{
			int id = new_states[i]->id;
			if(!visited[id]) // if this state was visited no need to explore it again
			{
				visited[id] = true;
				NFA_states[id] = new_states[i];
				q.push(new_states[i]);
			}
		}
	}
}

/**
 * this method finds the position of the state in states
 * and returns -1 if doesn't exist
 *
 * this method assumes that all states are sorted  and no redundant sub-states
 */
int DFA_Builder::find(const vector<FA_State*>& state,const vector<vector<FA_State*> > states)
{
	int size = (int)states.size() , stateSize;
	for(int i = 0 ; i < size;i++)
	{
		stateSize = states[i].size();
		if(stateSize != (int)state.size())
			continue;
		bool similar = true;
		for(int j = 0; j < stateSize;j++)
			if(state[j] != states[i][j])
			{
				similar = false;
				break;
			}
		if(similar)
			return i;
	}
	return -1;
}

DFA_Builder::~DFA_Builder()
{
}



