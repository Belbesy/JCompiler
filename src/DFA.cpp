/*
 * DFA.cpp
 *
 *  Created on: Apr 6, 2013
 *      Author: raed
 */

#include "DFA.h"

namespace std {

DFA_Builder::DFA_Builder(FSA_TABLE NFATable_,vector<string> patterns_ ,vector<char> all_inputs_)
{
	NFATable = NFATable_;
	patterns = patterns_;
	all_inputs = all_inputs_;
	statesNum = NFATable.size();
	visited = new bool[statesNum];
	state_id = 0;
}

/**
 * in this method DFA logic was separated from subset construction,
 * this means DFA states were expressed using FA_State class , and were stored in DFA vector
 *
 * and sub-states of each state ware added in a separate vector called "DFA_states" , this vector
 * keeps only the id if state not the state itself
 *
 * lazy addition of sub-states was used to avoid duplicates, so visited array was used,
 * first mark sub-states you want add to you state then a flush of this sub-states in done
 *  in a separate step (flush_new_state) when we are done with sub-states addition
 *
 *sub-set construction was implemented using BFS ,each new state we added to the table is added
 *sub-set to the queue to explore it later
 */
void DFA_Builder::NFA_to_DFA()
{
	for(int i = 0;  i < statesNum;i++)
		visited[i] = false;

	int state = NFATable.front()->id;

	empty_closure(state);
	flush_new_state();


	// start BFS
	queue<int> q;
	q.push(0);
	int front , size , stateSize;
	while(!q.empty())
	{
		front = q.front();
		q.pop();
		stateSize = (int)DFA_states[front].size();
		size = all_inputs.size(); // TODO get this array somehow
		for(int i = 0; i < size;i++)
		{
			char input = all_inputs[i];
			// apply this input to all state states
			for(int j = 0 ;j < stateSize;j++)
			{
				// apply this input to NFA state "state"
				state = DFA_states[front][i];
				vector<FA_State*> NFA_states;
				NFATable[state]->getTransition("" + input, NFA_states);
				for (int i = 0; i < (int) NFA_states.size(); i++)
					empty_closure(NFA_states[i]->id);
			}
			// now get the new state generated by this input
			int added_state  = flush_new_state();
			if(added_state == state_id-1) // check whether it exists before or not
				// new state,add it to your DFA states , and add to be queue to be explored later
				q.push(DFA_states.size()-1);
			DFA[front]->AddTransition(input+"" , DFA[added_state]); // TODO change input+""
		}
	}
}

/**
 * this method gets states visited array and adds them to DFA_states
 * creation of DFA state should be done here
 *
 * and returns the id of the added state
 *if this id == state_id , then it's a new state
 *else this state exists before and the returned id is its id
 */
int DFA_Builder::flush_new_state()
{
	// accumulate all visited states into new one state
	vector<int> sub_states;
	int matched_pattern = -1;
	for(int i = 0 ; i < statesNum;i++)
		if(visited[i])
		{
			sub_states.push_back(i);
			visited[i] = false;
			if(NFATable[i]->acceptingState)
				if(matched_pattern == -1)
					// first time to get final state
					matched_pattern = NFATable[i]->matchedPattern;
				else
					// get highest priority one
					matched_pattern = min(NFATable[i]->matchedPattern , matched_pattern);
		}
//	sort(sub_states.begin() , sub_states.end()); // this sort will help comparing state later

	// insert this state into your FA states tables
	int index = find(sub_states,DFA_states);
	if(index == -1)
	{
		DFA_states.push_back(sub_states);
		FA_State* new_FA_state = new FA_State(state_id++);
		if(matched_pattern != -1) // final state
		{
			// TODO make sure that you have table of all patterns ( vector<int> patterns)
			new_FA_state->acceptingState = true;
			new_FA_state->matchedPattern = matched_pattern;
		}
		DFA.push_back(new_FA_state);
		return state_id-1;
	}
	return index;
}

/**
 * this method calculates the epsilon transitive closure of the state "state"
 * but it doesn't return anything , instead it marks this state as visited to be added later
 *
 * Using BFS
 */
void DFA_Builder::empty_closure(int state)
{
	int front , size;
	queue<int> q;
	visited[state] = true;
	q.push(state);
	while(!q.empty())
	{
		front = q.front();
		q.pop();

		// get epsilon transition from current state
		vector<FA_State*> new_states;
		NFATable[front]->getTransition("\\L" , new_states); // TODO change \\L

		// add states to queue to be explored later
		size = (int)new_states.size();
		for(int i = 0 ; i < size;i++)
		{
			int id = new_states[i]->id;
			if(!visited[id]) // if this state was visited no need to explore it again
			{
				visited[id] = true;
				q.push(id);
			}
		}
	}
}

/**
 * this method finds the position of the state in states
 * and returns -1 if doesn't exist
 *
 * this method assumes that all states are sorted  and no redundant sub-states
 */
int DFA_Builder::find(const vector<int>& state,const vector<vector<int> > states)
{
	int size = (int)states.size() , stateSize;
	for(int i = 0 ; i < size;i++)
	{
		stateSize = states[i].size();
		if(stateSize != (int)state.size())
			continue;
		bool similar = true;
		for(int j = 0; j < stateSize;j++)
			if(state[j] != states[i][j])
			{
				similar = false;
				break;
			}
		if(similar)
			return i;
	}
	return -1;
}

DFA_Builder::~DFA_Builder()
{
}



} /* namespace std */
