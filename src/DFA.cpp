/*
 * DFA.cpp
 *
 *  Created on: Apr 6, 2013
 *      Author: raed
 */

#include "DFA.h"

const char EPSILON = char(8);



DFA_Builder::DFA_Builder(FSA_TABLE NFATable_,vector<string> patterns_ ,vector<char> all_inputs_)
{
	NFATable = NFATable_;
	patterns = patterns_;
	all_inputs = all_inputs_;
	statesNum = NFATable.size();
	visited = new bool[statesNum];
	state_id = 0;
}


/**
 * in this method DFA logic was separated from subset construction,
 * this means DFA states were expressed using FA_State class , and were stored in DFA vector
 *
 * and sub-states of each state ware added in a separate vector called "DFA_states" , this vector
 * keeps only the id if state not the state itself
 *
 * lazy addition of sub-states was used to avoid duplicates, so visited array was used,
 * first mark sub-states you want add to you state then a flush of this sub-states in done
 *  in a separate step (flush_new_state) when we are done with sub-states addition
 *
 *sub-set construction was implemented using BFS ,each new state we added to the table is added
 *sub-set to the queue to explore it later
 */
void DFA_Builder::NFA_to_DFA()
{
	for(int i = 0;  i < statesNum;i++)
		visited[i] = false;

	int state = NFATable.front()->id;

	empty_closure(state);
	flush_new_state();


	cout << "Start BFS" << endl;
	// start BFS
	queue<int> q;
	q.push(0);
	int front , size , stateSize;
	while(!q.empty())
	{
		front = q.front();
		q.pop();
//		cout << "Exploring State " << front << endl;

		stateSize = (int)DFA_states[front].size();
		size = all_inputs.size(); // get this array somehow
		for(int i = 0; i < size;i++)
		{
			char input = all_inputs[i];
//			cout << " Apply input " << input << endl;
			// apply this input to all state states
//			cout << " Front " << front << " " << input << " ";
			for(int j = 0 ;j < stateSize;j++)
			{
				// apply this input to NFA state "state"
				state = DFA_states[front][j];
//				cout << " Apply to state " << state << endl;
				vector<FA_State*> NFA_states;
				NFATable[state]->getTransition(input, NFA_states);
//				if(front == 0)
//					cout << NFA_states.size() << " ";
				for (int k = 0; k < (int) NFA_states.size();k++)
				{
//					cout << " Got sub-state " << NFA_states[k]->id << endl;
					empty_closure(NFA_states[k]->id);
				}
			}
//			cout << endl;
			// now get the new state generated by this input
			int added_state = flush_new_state();
			if (added_state != -1)
			{
				if (added_state == state_id - 1 && added_state != front) // check whether it exists before or not
				// new state,add it to your DFA states , and add to be queue to be explored later
					q.push(added_state);
//				if(front == 0)
//					cout << "State 0 " <<input  << " To " << added_state << endl ;
				DFA[front]->AddTransition(input, DFA[added_state]);
//				cout << "Edge from state " << char(front+'A') << " to " << char(added_state+'A') << " input " << input << endl;
			}
		}
	}
//	for(int i = 0 ;  i < state_id;i++)
//	{
//		cout << "State " << i  << " ";
//		for(int j = 0 ; j < (int)DFA_states[i].size();j++)
//			cout << DFA_states[i][j] << " ";
//		cout << endl;
//	}
}

/**
 * this method gets states visited array and adds them to DFA_states
 * creation of DFA state should be done here
 *
 * and returns the id of the added state
 *if this id == state_id , then it's a new state
 *else this state exists before and the returned id is its id
 */
int DFA_Builder::flush_new_state()
{
	// accumulate all visited states into new one state
	vector<int> sub_states;
	int matched_pattern = -1;
	for(int i = 0 ; i < statesNum;i++)
		if(visited[i])
		{
			sub_states.push_back(i);
			visited[i] = false;
			if(NFATable[i]->acceptingState)
				if(matched_pattern == -1)
					// first time to get final state
					matched_pattern = NFATable[i]->matched_pattern;
				else
					// get highest priority one
					matched_pattern = min(NFATable[i]->matched_pattern , matched_pattern);
		}
	if(sub_states.size() == 0)
		return -1;

	// insert this state into your FA states tables
	int index = find(sub_states,DFA_states);
	if(index == -1)
	{
		DFA_states.push_back(sub_states);
		FA_State* new_FA_state = new FA_State(state_id++);
		if(matched_pattern != -1) // final state
		{
			//  make sure that you have table of all patterns ( vector<int> patterns)
			new_FA_state->acceptingState = true;
			new_FA_state->matched_pattern = matched_pattern;
		}
		DFA.push_back(new_FA_state);
		return state_id-1;
	}
	return index;
}

/**
 * this method calculates the epsilon transitive closure of the state "state"
 * but it doesn't return anything , instead it marks this state as visited to be added later
 *
 * Using BFS
 */
void DFA_Builder::empty_closure(int state)
{
	int front , size;
	queue<int> q;
	visited[state] = true;
	q.push(state);
	while(!q.empty())
	{
		front = q.front();
		q.pop();

		// get epsilon transition from current state
		vector<FA_State*> new_states;
		NFATable[front]->getTransition(EPSILON, new_states);

		// add states to queue to be explored later
		size = (int)new_states.size();
		for(int i = 0 ; i < size;i++)
		{
			int id = new_states[i]->id;
			if(!visited[id]) // if this state was visited no need to explore it again
			{
				visited[id] = true;
				q.push(id);
			}
		}
	}
}

/**
 * this method finds the position of the state in states
 * and returns -1 if doesn't exist
 *
 * this method assumes that all states are sorted  and no redundant sub-states
 */
int DFA_Builder::find(const vector<int>& state,const vector<vector<int> > states)
{
	int size = (int)states.size() , stateSize;
	for(int i = 0 ; i < size;i++)
	{
		stateSize = states[i].size();
		if(stateSize != (int)state.size())
			continue;
		bool similar = true;
		for(int j = 0; j < stateSize;j++)
			if(state[j] != states[i][j])
			{
				similar = false;
				break;
			}
		if(similar)
			return i;
	}
	return -1;
}

DFA_Builder::~DFA_Builder()
{
}



